
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <title>Syntax Â· OpenFL ActionScript 3.0 Conversion Guide</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="HonKit 6.0.1">
        
        
        
    
    <link rel="stylesheet" href="../../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../../gitbook/@honkit/honkit-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/@honkit/honkit-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="variables.html" />
    
    
    <link rel="prev" href="./" />
    

    </head>
    <body>
        
<div class="book honkit-cloak">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="../../">
            
                <a href="../../">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="../../history.html">
            
                <a href="../../history.html">
            
                    
                    A Short History
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="../">
            
                <a href="../">
            
                    
                    Comparing Haxe and ActionScript
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.1" data-path="../overview.html">
            
                <a href="../overview.html">
            
                    
                    Overview
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2" data-path="./">
            
                <a href="./">
            
                    
                    Deep Dive
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter active" data-level="1.3.2.1" data-path="syntax.html">
            
                <a href="syntax.html">
            
                    
                    Syntax
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2.2" data-path="variables.html">
            
                <a href="variables.html">
            
                    
                    Variables
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2.3" data-path="data-types.html">
            
                <a href="data-types.html">
            
                    
                    Data Types
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2.4" data-path="operators.html">
            
                <a href="operators.html">
            
                    
                    Operators
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="../../automatic-conversion/">
            
                <a href="../../automatic-conversion/">
            
                    
                    Automatic Conversion
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.4.1" data-path="../../automatic-conversion/as3hx/">
            
                <a href="../../automatic-conversion/as3hx/">
            
                    
                    AS3HX
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.5" data-path="../../glossary/">
            
                <a href="../../glossary/">
            
                    
                    Glossary
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.5.1" data-path="../../glossary/error-messages.html">
            
                <a href="../../glossary/error-messages.html">
            
                    
                    Error Messages
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.2" data-path="../../glossary/cheat-sheet.html">
            
                <a href="../../glossary/cheat-sheet.html">
            
                    
                    Cheat Sheet
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.6" data-path="../../ui-components-fl-packages.html">
            
                <a href="../../ui-components-fl-packages.html">
            
                    
                    UI Components
            
                </a>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://github.com/honkit/honkit" target="blank" class="gitbook-link">
            Published with HonKit
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="../.." >Syntax</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="syntax">Syntax</h1>
<h2 id="case-sensitivity">Case Sensitivity</h2>
<p>ActionScript 3.0 and Haxe are both case-sensitive languages, so both of the following are different variables:</p>
<pre><code class="lang-haxe"><span class="hljs-keyword">var</span> hello:<span class="hljs-type">String</span>;
<span class="hljs-keyword">var</span> Hello:<span class="hljs-type">String</span>;
</code></pre>
<h2 id="semicolons">Semicolons</h2>
<p>ActionScript 3.0 and Haxe both use semicolons (<code>;</code>) to terminate a statement. Good coding standards in ActionScript encourage the use of semicolons, but they are optional.</p>
<p>In Haxe, the use of semicolons is not optional.</p>
<pre><code class="lang-haxe"><span class="hljs-keyword">var</span> hello:<span class="hljs-type">String</span>; <span class="hljs-comment">// correct</span>
<span class="hljs-keyword">var</span> hello:<span class="hljs-type">String </span>// incorrect
</code></pre>
<h2 id="parentheses">Parentheses</h2>
<p>In ActionScript 3.0, parentheses (<code>()</code>) can be used in three ways, but only two of these are valid in Haxe.</p>
<p>You can use parentheses to group operations:</p>
<pre><code class="lang-haxe"><span class="hljs-built_in">trace</span> (<span class="hljs-number">1</span> + (<span class="hljs-number">2</span> * <span class="hljs-number">3</span>)); <span class="hljs-comment">// 7</span>
<span class="hljs-built_in">trace</span> ((<span class="hljs-number">1</span> + <span class="hljs-number">2</span>) * <span class="hljs-number">3</span>); <span class="hljs-comment">// 9</span>
</code></pre>
<p>You can also use parentheses to pass one or more parameters to functions or methods:</p>
<pre><code class="lang-haxe"><span class="hljs-built_in">trace</span> (<span class="hljs-string">"hello"</span>);
</code></pre>
<p>ActionScript also supports the use of commas to separate multiple expressions and return the result of the final expression. For example:</p>
<pre><code class="lang-ActionScript"><span class="hljs-keyword">var</span> a:int = <span class="hljs-number">1</span>;
<span class="hljs-keyword">var</span> b:int = <span class="hljs-number">2</span>;
trace ((a++, b++, a + b)); <span class="hljs-comment">// 5</span>
</code></pre>
<p>The above syntax can be confusing, and is not supported in Haxe. The same code can be handled by expanding the expression:</p>
<pre><code class="lang-haxe"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;
<span class="hljs-keyword">var</span> b = <span class="hljs-number">2</span>;
a++;
b++;
<span class="hljs-built_in">trace</span> (a + b);
</code></pre>
<p>...or using a function:</p>
<pre><code class="lang-haxe"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;
<span class="hljs-keyword">var</span> b = <span class="hljs-number">2</span>;
<span class="hljs-built_in">trace</span> (<span class="hljs-title function_"><span class="hljs-keyword">function</span> </span>() { a++; b++; <span class="hljs-keyword">return</span> a + b; } ());
</code></pre>
<h2 id="code-blocks">Code Blocks</h2>
<p>Code encased by curly braces (<code>{}</code>) are called a code block. The body of many portions of ActionScript and Haxe are grouped together using code blocks.</p>
<pre><code class="lang-haxe"><span class="hljs-keyword">public</span> <span class="hljs-title function_"><span class="hljs-keyword">function</span> <span class="hljs-title">hello</span> </span>():<span class="hljs-type">String </span>{

    <span class="hljs-keyword">return</span> <span class="hljs-string">"World"</span>;

}
</code></pre>
<pre><code class="lang-haxe"><span class="hljs-keyword">if</span> (raining) {

    useUmbrella ();

}
</code></pre>
<h2 id="whitespace">Whitespace</h2>
<p>Spaces, tabs and line breaks are referred to as whitespace. Actionscript and Haxe both allow whitespace to make code easier to read.</p>
<pre><code class="lang-haxe"><span class="hljs-title class_"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>{

    <span class="hljs-keyword">public</span> <span class="hljs-title function_"><span class="hljs-keyword">function</span> <span class="hljs-title">new</span> </span>() {

    }

}

<span class="hljs-title class_"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span> </span>{ <span class="hljs-keyword">public</span> <span class="hljs-title function_"><span class="hljs-keyword">function</span> <span class="hljs-title">new</span></span>() {} }
</code></pre>
<h2 id="comments">Comments</h2>
<p>Actionscript and Haxe both allow for single-line or multi-line comments. A comment will not be compiled, allowing the addition of helpful notes or as a method of quickly disabling code.</p>
<pre><code class="lang-haxe"><span class="hljs-comment">// This is a single line comment</span>

<span class="hljs-comment">/* This is
   a multi-line
   comment */</span>
</code></pre>
<h2 id="literals">Literals</h2>
<p>A literal is a fixed value in your code, Haxe and ActionScript are similar in the types of literals you can use:</p>
<pre><code class="lang-haxe"><span class="hljs-number">100</span>
<span class="hljs-number">-2.1</span>
<span class="hljs-string">"hello"</span>
<span class="hljs-literal">null</span>
<span class="hljs-literal">true</span>
<span class="hljs-literal">false</span>
</code></pre>
<p>ActionScript has an <code>undefined</code> literal which is not used in Haxe. The following returns <code>undefined</code> in <code>ActionScript</code>, but is a compile error in Haxe:</p>
<pre><code class="lang-haxe">object = { a: <span class="hljs-type"></span>"b<span class="hljs-string">", c: "</span>d<span class="hljs-string">" };
trace (object.e);
</span></code></pre>
<p>Instead, use the Haxe <code>Reflect</code> class to check if a field exists, or use static types.</p>
<pre><code class="lang-haxe"><span class="hljs-keyword">if</span> (Reflect.hasField (object, <span class="hljs-string">"e"</span>)) {

    <span class="hljs-built_in">trace</span> (Reflect.field (object, <span class="hljs-string">"e"</span>));

}
</code></pre>
<h2 id="square-brackets">Square Brackets</h2>
<p>In ActionScript and Haxe, square brackets (<code>[]</code>) can be used to define an array literal:</p>
<pre><code class="lang-haxe"><span class="hljs-keyword">var</span> colors = [ <span class="hljs-string">"red"</span>, <span class="hljs-string">"blue"</span>, <span class="hljs-string">"green"</span> ];
</code></pre>
<p>Square brackets can also be used to access array values:</p>
<pre><code class="lang-haxe"><span class="hljs-keyword">var</span> firstColor = colors[<span class="hljs-number">0</span>];
</code></pre>
<p>Haxe allows support for array access on user-created abstract objects, in addition to core types.</p>
<p>ActionScript also allows the use of square brackets to access fields using a string-based name, but this is not supported in Haxe. Use the <code>Reflect</code> class in Haxe in order to reference a field dynamically.</p>
<p><em>ActionScript 3.0</em></p>
<pre><code class="lang-ActionScript">clip.x = <span class="hljs-number">100</span>;
clip[<span class="hljs-string">"y"</span>] = <span class="hljs-number">100</span>;
</code></pre>
<p><em>Haxe</em></p>
<pre><code class="lang-haxe">clip.x = <span class="hljs-number">100</span>;
Reflect.setField (clip, <span class="hljs-string">"y"</span>, <span class="hljs-number">100</span>);
</code></pre>
<h2 id="angle-brackets">Angle Brackets</h2>
<p>ActionScript 3.0 uses angle brackets (<code>&lt;&gt;</code>) for the <code>Vector.&lt;&gt;</code>. Haxe provides support for <em>type parameters</em> in the <code>Array&lt;&gt;</code>, <code>Map&lt;&gt;</code> and multiple other types in the language, and allows use of type parameters in user classes as well.</p>
<p>When describing the type of an <code>Array</code>, ActionScript will always treat the array as if it is dynamic. In Haxe, arrays are typed based on their contents, which improves performance and can eliminate confusing errors:</p>
<pre><code class="lang-haxe"><span class="hljs-keyword">var</span> values:<span class="hljs-type">Array</span>&lt;<span class="hljs-keyword">Int</span>&gt; = [ <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span> ];
<span class="hljs-keyword">var</span> names:<span class="hljs-type">Array</span>&lt;<span class="hljs-keyword">String</span>&gt; = [ <span class="hljs-string">"Doug"</span>, <span class="hljs-string">"Richard"</span>, <span class="hljs-string">"Harrison"</span> ];
</code></pre>
<h2 id="arrow-tokens">Arrow Tokens</h2>
<p>Haxe supports a special arrow token (<code>-&gt;</code>) syntax, which is used when describing a function. The ActionScript does not allow for different types based on the signature of a function. Instead, every function in ActionScript is described as type <code>Function</code>. Haxe allows for <code>Dynamic</code> to describe any function, but uses "arrow tokens" when a function signature is described specifically. For example, a function that accepts a <code>Bool</code> and returns an <code>Int</code> would be described as <code>Bool-&gt;Int</code>, and a function that accepts two boolean arguments instead would be <code>Bool-&gt;Bool-&gt;Int</code></p>
<pre><code class="lang-haxe"><span class="hljs-keyword">private</span> <span class="hljs-title function_"><span class="hljs-keyword">function</span> <span class="hljs-title">onMouseDown</span> </span>(x:<span class="hljs-type">Float</span>, y:<span class="hljs-type">Float</span>):<span class="hljs-type">Void </span>{

}
</code></pre>
<pre><code class="lang-haxe"><span class="hljs-keyword">var</span> handler:<span class="hljs-type">Float-&gt;Float-&gt;Void </span>= onMouseDown;
handler (<span class="hljs-number">100</span>, <span class="hljs-number">100</span>);
</code></pre>
<h2 id="keywords">Keywords</h2>
<p>ActionScript and Haxe share many reserved words and keywords:</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>break</code></td>
<td><code>case</code></td>
<td><code>catch</code></td>
</tr>
<tr>
<td><code>class</code></td>
<td><code>continue</code></td>
<td><code>default</code></td>
</tr>
<tr>
<td><code>do</code></td>
<td><code>dynamic</code></td>
<td><code>else</code></td>
</tr>
<tr>
<td><code>extends</code></td>
<td><code>false</code></td>
<td><code>for</code></td>
</tr>
<tr>
<td><code>function</code></td>
<td><code>if</code></td>
<td><code>implements</code></td>
</tr>
<tr>
<td><code>import</code></td>
<td><code>in</code></td>
<td><code>interface</code></td>
</tr>
<tr>
<td><code>new</code></td>
<td><code>null</code></td>
<td><code>override</code></td>
</tr>
<tr>
<td><code>package</code></td>
<td><code>private</code></td>
<td><code>public</code></td>
</tr>
<tr>
<td><code>return</code></td>
<td><code>static</code></td>
<td><code>super</code></td>
</tr>
<tr>
<td><code>switch</code></td>
<td><code>this</code></td>
<td><code>throw</code></td>
</tr>
<tr>
<td><code>true</code></td>
<td><code>try</code></td>
<td><code>var</code></td>
</tr>
<tr>
<td><code>while</code></td>
</tr>
</tbody>
</table>
<p>The Haxe programming language is designed to limit the number of keywords, so there are a number of keywords which are in ActionScript 3.0 that are not keywords in Haxe:</p>
<ul>
<li><p><code>as</code></p>
<p> In ActionScript 3.0, <code>as</code> is used for casting. Adobe references <code>cast</code> as a "future" keyword that has not been implemented in the language.</p>
<pre><code class="lang-ActionScript"> <span class="hljs-keyword">var</span> clip:MovieClip = event.currentTarget <span class="hljs-keyword">as</span> MovieClip;
</code></pre>
<p> Haxe uses <code>cast</code> when casting between types, in order to perform a safe cast (which is slower, but throws an error if it is not possible), use parentheses:</p>
<pre><code class="lang-haxe"> <span class="hljs-keyword">var</span> clip = <span class="hljs-keyword">cast</span> (event.currentTarget, MovieClip);
</code></pre>
<p> ...otherwise, an unsafe cast occurs without parentheses and a second argument.</p>
<pre><code class="lang-haxe"> <span class="hljs-keyword">var</span> clip:<span class="hljs-type">MovieClip </span>= <span class="hljs-keyword">cast</span> event.currentTarget;
</code></pre>
</li>
<li><p><code>const</code></p>
<p> Actionscript uses the <code>const</code> keyword to define a constant value. Because Haxe supports inlining, a <code>const</code> keyword is not necessary.</p>
<pre><code class="lang-haxe"> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">var</span> gravity = <span class="hljs-number">9.8</span>;
</code></pre>
</li>
<li><p><code>each</code></p>
<p> ActionScript has separate "for in" or "for each in" loops, but in Haxe these are simplified to a single "for in" loop.</p>
<pre><code class="lang-haxe"> <span class="hljs-keyword">var</span> fruits = [ <span class="hljs-string">"apple"</span>, <span class="hljs-string">"pear"</span>, <span class="hljs-string">"orange"</span> ];

 <span class="hljs-keyword">for</span> (fruit <span class="hljs-keyword">in</span> fruits) {

     <span class="hljs-built_in">trace</span> (value);

 }
</code></pre>
<p> If you need to iterate over the names of the fields in an object, use <code>Reflect.fields</code>:</p>
<p> ```haxe
 var object = { a: "b", c: "d" };</p>
<p> for (field in Reflect.fields (object)) {</p>
<pre><code> trace (field); // returns "a" then "c"
</code></pre><p> }
 ```haxe</p>
</li>
<li><p><code>final</code></p>
<p> ActionScript uses the <code>final</code> keyword to specify a class that cannot be extended. Haxe supports the same, but it uses a <code>@:final</code> meta-data tag instead:</p>
<pre><code class="lang-haxe"> <span class="hljs-meta">@:final class Test {</span>

 }
</code></pre>
</li>
<li><p><code>finally</code></p>
<p> Haxe does not support <code>try/catch/finally</code> so cleanup logic must occur inside a <code>catch</code> in addition to after the <code>try/catch</code> statement.</p>
</li>
<li><p><code>include</code></p>
<p> Haxe does not support an <code>include</code> keyword, there are methods of replicating the same behavior using a custom macro, but in general, it is recommended that classes, typedefs, <code>using</code> and other techniques are implemented to share code within a project.</p>
</li>
<li><p><code>instanceof</code></p>
<p> The ActionScript 3.0 keyword, <code>instanceof</code>, can be replaced with <code>Std.is</code></p>
<pre><code class="lang-haxe"> <span class="hljs-built_in">trace</span> (Std.<span class="hljs-keyword">is</span> (sprite, DisplayObject));
 <span class="hljs-built_in">trace</span> (Std.<span class="hljs-keyword">is</span> (<span class="hljs-string">"hello"</span>, <span class="hljs-keyword">String</span>));
 <span class="hljs-built_in">trace</span> (Std.<span class="hljs-keyword">is</span> (<span class="hljs-number">5</span>, <span class="hljs-keyword">Int</span>));
</code></pre>
</li>
<li><p><code>internal</code></p>
<p> Haxe has support for both <code>public</code> and <code>private</code> keywords, which are simpler to understand, and cover the majority of use cases.</p>
<p> Haxe supports three meta-data tags (<code>@:allow</code>, <code>@:access</code> and <code>@:privateAccess</code>) which each provide different methods of accessing a <code>private</code> member. This can provide the same function as <code>internal</code>, or like "friend classes" in other languages.</p>
<pre><code class="lang-haxe"> <span class="hljs-title class_"><span class="hljs-keyword">class</span> <span class="hljs-title">Secret</span> </span>{

     <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> password:<span class="hljs-type">String</span>;

 }
</code></pre>
<pre><code class="lang-haxe"> <span class="hljs-meta">@:access</span>(Secret)
 <span class="hljs-title class_"><span class="hljs-keyword">class</span> <span class="hljs-title">Login</span> </span>{

     <span class="hljs-keyword">public</span> <span class="hljs-title function_"><span class="hljs-keyword">function</span> <span class="hljs-title">new</span> </span>() {

         <span class="hljs-keyword">var</span> password = Secret.password;

     }

 }
</code></pre>
</li>
<li><p><code>namespace</code></p>
<p> Haxe does not support custom namespaces like ActionScript 3.0.</p>
</li>
<li><p><code>native</code></p>
<p> ActionScript has a <code>native</code> keyword when a method is a wrapper around a native method. Haxe has <code>extern</code> classes for working with native APIs, and depending on the platform, "CFFI" or "JNI" for accessing methods or properties between different runtime environments.</p>
<p> On HTML5, it is possible to also implement <code>untyped</code> JavaScript code directly.</p>
<pre><code class="lang-haxe"> <span class="hljs-keyword">untyped</span> __js__ (<span class="hljs-string">"window.alert ('Hello!')"</span>);
</code></pre>
<p> ...extern classes tend to help provide a nicer API, however:</p>
<pre><code class="lang-haxe"> Browser.alert (<span class="hljs-string">"Hello!"</span>);
</code></pre>
</li>
<li><p><code>protected</code></p>
<p> The <code>private</code> keyword in Haxe behaves similar to the <code>protected</code> keyword in ActionScript.</p>
</li>
<li><p><code>typeof</code></p>
<p> ActionScript 3.0 uses the <code>typeof</code> keyword to return a generic String value for the current object:</p>
<pre><code class="lang-ActionScript"> <span class="hljs-keyword">switch</span> (<span class="hljs-keyword">typeof</span> obj) {
     <span class="hljs-keyword">case</span> <span class="hljs-string">"boolean"</span>: trace (<span class="hljs-string">"obj is a boolean"</span>); <span class="hljs-keyword">break</span>;
     <span class="hljs-keyword">case</span> <span class="hljs-string">"number"</span>: trace (<span class="hljs-string">"obj is a number"</span>); <span class="hljs-keyword">break</span>;
     <span class="hljs-keyword">default</span>:
 }
</code></pre>
<p> Haxe allows a similar check using <code>Type.typeof</code>, though it returns a static type (not a String).</p>
<pre><code class="lang-haxe"> <span class="hljs-keyword">switch</span> (Type.typeof (obj)) {
     <span class="hljs-keyword">case</span> TBool: <span class="hljs-type">trace </span>(<span class="hljs-string">"obj is a boolean"</span>);
     <span class="hljs-keyword">case</span> TInt, TFloat: <span class="hljs-type">trace </span>(<span class="hljs-string">"obj is a number"</span>);
     <span class="hljs-keyword">default</span>:<span class="hljs-type"></span>
 }
</code></pre>
</li>
<li><p><code>use</code></p>
<p> Haxe does not support custom namespaces like ActionScript 3.0.</p>
</li>
<li><p><code>void</code></p>
<p> Haxe uses <code>Void</code> instead of <code>void</code> (for better consistency with other type names).</p>
</li>
<li><p><code>with</code></p>
<p> The ActionScript 3.0 <code>with</code> keyword is a shorthand approach that can reduce the amount of code that is written, but it has some limitations (such as not being able to declare new variables inside) which can make it unpredictable to use.</p>
<pre><code class="lang-ActionScript"> <span class="hljs-keyword">var</span> clip = <span class="hljs-keyword">new</span> MovieClip ();
 <span class="hljs-keyword">with</span> (clip) {
     x = <span class="hljs-number">100</span>;
     y = <span class="hljs-number">100</span>;
 }
</code></pre>
<p> Haxe does not support the <code>with</code> keyword, it may make code more verbose, but it can make code simpler to understand and more reliable.</p>
<pre><code class="lang-haxe"> <span class="hljs-keyword">var</span> clip = <span class="hljs-keyword">new</span><span class="hljs-type"></span> MovieClip ();
 clip.x = <span class="hljs-number">100</span>;
 clip.y = <span class="hljs-number">100</span>;
</code></pre>
</li>
</ul>
<p>Haxe also has additional keywords that are not defined in ActionScript:</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>cast</code></td>
<td><code>enum</code></td>
<td><code>extern</code></td>
</tr>
<tr>
<td><code>inline</code></td>
<td><code>never</code></td>
<td><code>typedef</code></td>
</tr>
<tr>
<td><code>untyped</code></td>
<td><code>using</code></td>
</tr>
</tbody>
</table>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="./" class="navigation navigation-prev " aria-label="Previous page: Deep Dive">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="variables.html" class="navigation navigation-next " aria-label="Next page: Variables">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"Syntax","level":"1.3.2.1","depth":3,"next":{"title":"Variables","level":"1.3.2.2","depth":3,"path":"comparing-haxe-and-actionscript/deep-dive/variables.md","ref":"comparing-haxe-and-actionscript/deep-dive/variables.md","articles":[]},"previous":{"title":"Deep Dive","level":"1.3.2","depth":2,"path":"comparing-haxe-and-actionscript/deep-dive/README.md","ref":"comparing-haxe-and-actionscript/deep-dive/README.md","articles":[{"title":"Syntax","level":"1.3.2.1","depth":3,"path":"comparing-haxe-and-actionscript/deep-dive/syntax.md","ref":"comparing-haxe-and-actionscript/deep-dive/syntax.md","articles":[]},{"title":"Variables","level":"1.3.2.2","depth":3,"path":"comparing-haxe-and-actionscript/deep-dive/variables.md","ref":"comparing-haxe-and-actionscript/deep-dive/variables.md","articles":[]},{"title":"Data Types","level":"1.3.2.3","depth":3,"path":"comparing-haxe-and-actionscript/deep-dive/data-types.md","ref":"comparing-haxe-and-actionscript/deep-dive/data-types.md","articles":[]},{"title":"Operators","level":"1.3.2.4","depth":3,"path":"comparing-haxe-and-actionscript/deep-dive/operators.md","ref":"comparing-haxe-and-actionscript/deep-dive/operators.md","articles":[]}]},"dir":"ltr"},"config":{"plugins":[],"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"pluginsConfig":{"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"theme":"default","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56},"embedFonts":false},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"title":"OpenFL ActionScript 3.0 Conversion Guide","gitbook":"*"},"file":{"path":"comparing-haxe-and-actionscript/deep-dive/syntax.md","mtime":"2024-10-11T22:30:45.754Z","type":"markdown"},"gitbook":{"version":"6.0.1","time":"2024-10-11T22:31:19.963Z"},"basePath":"../..","book":{"language":""}});
        });
    </script>
</div>

        
    <noscript>
        <style>
            .honkit-cloak {
                display: block !important;
            }
        </style>
    </noscript>
    <script>
        // Restore sidebar state as critical path for prevent layout shift
        function __init__getSidebarState(defaultValue){
            var baseKey = "";
            var key = baseKey + ":sidebar";
            try {
                var value = localStorage[key];
                if (value === undefined) {
                    return defaultValue;
                }
                var parsed = JSON.parse(value);
                return parsed == null ? defaultValue : parsed;
            } catch (e) {
                return defaultValue;
            }
        }
        function __init__restoreLastSidebarState() {
            var isMobile = window.matchMedia("(max-width: 600px)").matches;
            if (isMobile) {
                // Init last state if not mobile
                return;
            }
            var sidebarState = __init__getSidebarState(true);
            var book = document.querySelector(".book");
            // Show sidebar if it enabled
            if (sidebarState && book) {
                book.classList.add("without-animation", "with-summary");
            }
        }

        try {
            __init__restoreLastSidebarState();
        } finally {
            var book = document.querySelector(".book");
            book.classList.remove("honkit-cloak");
        }
    </script>
    <script src="../../gitbook/gitbook.js"></script>
    <script src="../../gitbook/theme.js"></script>
    
        
        <script src="../../gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="../../gitbook/@honkit/honkit-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

